You're right! I need to provide the **full implementation of `opensearch.py`**, which includes:
1. **Exact Match Lookup** (`query_valid_options`)
2. **Fuzzy Search for Similar Matches** (`query_did_you_mean`)

---

# **‚úÖ `opensearch.py` Implementation**
This file handles all interactions with **OpenSearch**, ensuring that:
- **Exact matches are checked first**.
- **If no exact match exists, we suggest close matches ("Did You Mean?")**.

```python
import os
import requests
import logging

logger = logging.getLogger(__name__)

# OpenSearch Configuration (Make sure the environment variable is set)
OPENSEARCH_URL = os.getenv("OPENSEARCH_URL", "http://localhost:9200/fps_um/_search")

async def query_valid_options(option_type):
    """
    Fetches valid options (formulary names, years, or drugs) from OpenSearch.
    Used for "follow_up" questions when details are missing.
    """
    query = {}

    if option_type == "formulary":
        query = {
            "size": 1000,
            "_source": ["formulary_name"],
            "query": {"match_all": {}}
        }
    elif option_type == "year":
        query = {
            "size": 1000,
            "_source": ["invoice_yr"],
            "query": {"match_all": {}}
        }
    elif option_type == "drug":
        query = {
            "size": 1000,
            "_source": ["brand_name"],
            "query": {"match_all": {}}
        }
    else:
        return []

    try:
        response = requests.post(OPENSEARCH_URL, json=query)
        
        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            options = list(set(hit["_source"][option_type] for hit in hits if option_type in hit["_source"]))
            return sorted(options)  # Returning sorted list of unique options
        else:
            logger.error(f"OpenSearch returned an error: {response.status_code}")
            return []

    except Exception as e:
        logger.error(f"Error querying OpenSearch: {str(e)}")
        return []

async def query_exact_match(user_input):
    """
    Checks if a user's input has an exact match in OpenSearch.
    If an exact match is found, we proceed without a "Did You Mean?" prompt.
    """
    query = {
        "size": 1,
        "_source": ["formulary_name"],
        "query": {
            "match_phrase": {
                "formulary_name.keyword": user_input
            }
        }
    }

    try:
        response = requests.post(OPENSEARCH_URL, json=query)
        
        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            
            if hits:
                return True  # Exact match found
            return False  # No exact match

        logger.error(f"OpenSearch query failed: {response.status_code}")
        return False  # If OpenSearch fails, assume no match

    except Exception as e:
        logger.error(f"Error querying OpenSearch: {str(e)}")
        return False

async def query_did_you_mean(user_input):
    """
    Searches OpenSearch for similar terms when user input does not match exactly.
    Uses fuzzy search to suggest potential matches.
    """
    query = {
        "size": 5,  # Limit results to top 5 matches
        "_source": ["formulary_name"],
        "query": {
            "fuzzy": {  # Use fuzzy search to find close matches
                "formulary_name": {
                    "value": user_input,
                    "fuzziness": "AUTO"
                }
            }
        }
    }

    try:
        response = requests.post(OPENSEARCH_URL, json=query)
        
        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            options = list(set(hit["_source"]["formulary_name"] for hit in hits if "formulary_name" in hit["_source"]))
            return sorted(options)  # Returning sorted list of unique matches
        else:
            logger.error(f"OpenSearch returned an error: {response.status_code}")
            return []

    except Exception as e:
        logger.error(f"Error querying OpenSearch: {str(e)}")
        return []
```

---

# **‚úÖ Explanation of OpenSearch Functions**
### **1Ô∏è‚É£ `query_valid_options(option_type)`**
- **Purpose**: Fetches **valid options** for `"follow_up"` responses.
- **Example Use Case**:
  - If a user asks for "WAC for Lipitor" but doesn't provide a year, **fetch all valid years**.
  - If a user asks for "All drugs under a formulary" but doesn't specify which formulary, **fetch all valid formularies**.

---

### **2Ô∏è‚É£ `query_exact_match(user_input)`**
- **Purpose**: Checks **if a user input has an exact match** in OpenSearch.
- **Example Use Case**:
  - User types "Express Scripts" ‚Üí **Check if this exists in OpenSearch**.
  - If an **exact match exists**, proceed normally.
  - If **no exact match**, perform **fuzzy search** for `"Did You Mean?"`.

---

### **3Ô∏è‚É£ `query_did_you_mean(user_input)`**
- **Purpose**: Uses **fuzzy search** to suggest close matches.
- **Example Use Case**:
  - User types "Expres Scripts" (misspelled).
  - OpenSearch finds close matches: `"Express Scripts"`, `"Express RX"`, `"Express Plan"`.
  - The bot **returns a `"did_you_mean"` response** with valid options.

---

## **‚úÖ Example Scenarios**

### **‚úÖ Scenario 1: Exact Match Found**
üë§ **User**: *"What is the WAC for Lipitor under Express Scripts?"*  
üîç **OpenSearch confirms exact match** ‚Üí ‚úÖ **Proceed normally**  
ü§ñ **Bot Response (JSON)**:
```json
{
  "response_type": "tool_calls",
  "tool_calls": [
    {
      "tool": "query_total_wac",
      "parameters": {
        "formulary_name": "Express Scripts",
        "year": 2023,
        "brand_name": "Lipitor"
      }
    }
  ]
}
```

---

### **‚úÖ Scenario 2: No Match, "Did You Mean?"**
üë§ **User**: *"What are the drugs under Expres Scipts?"*  
üîç **OpenSearch finds no exact match**  
üîç **Fuzzy search suggests closest matches**  
ü§ñ **Bot Response (JSON)**:
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean one of these?",
    "options": ["Express Scripts", "Express RX", "Express Plan"]
  }
}
```

---

### **‚úÖ Scenario 3: Follow-Up Needed**
üë§ **User**: *"What is the WAC for Lipitor?"*  
üîç **OpenSearch confirms "Lipitor" exists**  
üîç **But no year was provided!**  
ü§ñ **Bot Response (JSON)**:
```json
{
  "response_type": "follow_up",
  "follow_up": {
    "question": "Which year do you need?",
    "options": ["2021", "2022", "2023"]
  }
}
```

---

### **üöÄ Summary of Features**
‚úî **Step 1: Exact match search (`query_exact_match`)**  
‚úî **Step 2: Fuzzy search for similar matches (`query_did_you_mean`)**  
‚úî **Step 3: Fetch valid options when missing (`query_valid_options`)**  
‚úî **Ensures structured JSON responses for every case**  

üöÄ **Now your bot is fully intelligent, searches OpenSearch properly, and provides helpful suggestions!** Let me know if you need any refinements! üéØ

### **üîπ Handling User Response to "Did You Mean?"**
You want the bot to:
1. **If `"did_you_mean"` provides multiple options**, the user should select one and the bot should process it.
2. **If `"did_you_mean"` provides only one option**, the user can say "Yes" or confirm, and the bot should proceed automatically.
3. **If the user provides an unclear response**, the bot should prompt again.

---

## **‚úÖ Steps to Fix**
### **1Ô∏è‚É£ Modify `process_query()` in `ai_gateway.py`**
- If the user response comes **after a `"did_you_mean"`**, check:
  - If they said **"Yes" or "Confirm"**, use the single available option.
  - If they selected an option, proceed.
  - If the response is unclear, re-prompt.

```python
async def process_query(user_query, history):
    """
    Determines the context of the query before deciding whether to:
    - Process an NLP question
    - Query OpenSearch for exact/fuzzy matches
    - Handle responses to "Did You Mean?"
    - Perform a follow-up if necessary
    """
    
    # Step 1: Determine query intent
    context_result = await derive_context(user_query, history)
    context = context_result.get("context")

    # Check if last response was "Did You Mean?"
    last_bot_response = history[-1] if history else None
    if last_bot_response and last_bot_response.get("response_type") == "did_you_mean":
        did_you_mean_options = last_bot_response["did_you_mean"]["options"]

        # If user says "Yes", assume they accept the only option
        if len(did_you_mean_options) == 1 and user_query.lower() in ["yes", "confirm", "correct"]:
            entity_value = did_you_mean_options[0]  # Use the single available option
            entity_type = last_bot_response.get("did_you_mean").get("entity_type")
            history.append({"role": "user", "content": f"Selected: {entity_value}"})
        
        # If they specify one of the options, use it
        elif user_query in did_you_mean_options:
            entity_value = user_query
            entity_type = last_bot_response.get("did_you_mean").get("entity_type")
            history.append({"role": "user", "content": f"Selected: {entity_value}"})
        
        else:
            # If the user gives an invalid response, ask again
            return {
                "response_type": "did_you_mean",
                "did_you_mean": {
                    "question": "Please choose one of the options:",
                    "options": did_you_mean_options
                }
            }

        # Now that we have a confirmed entity, proceed with OpenSearch lookup
        exact_match = await query_valid_options(entity_type)
        if not exact_match:
            return {
                "response_type": "message",
                "message": {
                    "text": f"'{entity_value}' was not found in the database.",
                    "context": "error"
                }
            }

        # Proceed with formulating the correct tool call
        return {
            "response_type": "tool_calls",
            "tool_calls": [
                {
                    "tool": context_result["tool"],
                    "parameters": {entity_type: entity_value}
                }
            ]
        }

    # Handle Greetings
    if context == "greeting":
        return {
            "response_type": "message",
            "message": {
                "text": "Hello! How can I assist you today?",
                "context": "greeting"
            }
        }

    # Handle General NLP Queries
    if context == "nlp":
        return {
            "response_type": "message",
            "message": {
                "text": context_result["message"],
                "context": "info"
            }
        }

    # Handle Formulary Search Queries
    if context == "formulary_search":
        entity_type = context_result.get("entity_type")  
        entity_value = context_result.get("entity_value")  

        if not entity_type or not entity_value:
            return {
                "response_type": "message",
                "message": {
                    "text": "I couldn't determine the entity in your request.",
                    "context": "error"
                }
            }

        # Step 2: Check OpenSearch for exact match using the correct entity type
        exact_match = await query_valid_options(entity_type)

        if not exact_match:  # No exact match, try fuzzy search
            fuzzy_matches = await query_did_you_mean(entity_value)
            
            if fuzzy_matches:
                return {
                    "response_type": "did_you_mean",
                    "did_you_mean": {
                        "question": "Did you mean one of these?",
                        "options": fuzzy_matches,
                        "entity_type": entity_type
                    }
                }

        # Step 3: If an exact match exists, check if follow-up is needed
        missing_parameters = context_result.get("missing_parameters", [])

        if missing_parameters:
            options = await query_valid_options(missing_parameters[0])
            return {
                "response_type": "follow_up",
                "follow_up": {
                    "question": f"Could you provide {missing_parameters[0]}?",
                    "options": options
                }
            }

        # Step 4: If everything is provided, generate tool_calls
        return {
            "response_type": "tool_calls",
            "tool_calls": [
                {
                    "tool": context_result["tool"],
                    "parameters": context_result["parameters"]
                }
            ]
        }

    # Handle Unknown Queries
    if context == "unknown":
        return {
            "response_type": "message",
            "message": {
                "text": context_result["message"],
                "context": "error"
            }
        }

    # Default error handling
    return {
        "response_type": "message",
        "message": {
            "text": "I couldn't determine your request. Please clarify.",
            "context": "error"
        }
    }
```

---

## **‚úÖ Expected Bot Behavior After Fix**
### **Scenario 1: User Selects an Option**
üë§ **User**: *"What are the drugs under Expres Scipts?"*  
üîç **OpenSearch finds no exact match, but fuzzy search suggests options**  
ü§ñ **Bot Response (JSON)**:
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean one of these?",
    "options": ["Express Scripts", "Express RX", "Express Plan"],
    "entity_type": "formulary_name"
  }
}
```
üë§ **User**: *"Express RX"*
ü§ñ **Bot Proceeds with Query**

---

### **Scenario 2: User Says "Yes" When Only One Option Exists**
üë§ **User**: *"What are the drugs under Expres Scipts?"*  
üîç **OpenSearch finds one possible match: "Express Scripts"**  
ü§ñ **Bot Response (JSON)**:
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean Express Scripts?",
    "options": ["Express Scripts"],
    "entity_type": "formulary_name"
  }
}
```
üë§ **User**: *"Yes"*
ü§ñ **Bot Proceeds with Query Automatically**

---

### **Scenario 3: User Gives an Invalid Response**
üë§ **User**: *"What are the drugs under Expres Scipts?"*  
üîç **OpenSearch finds no exact match, but fuzzy search suggests options**  
ü§ñ **Bot Response (JSON)**:
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean one of these?",
    "options": ["Express Scripts", "Express RX", "Express Plan"],
    "entity_type": "formulary_name"
  }
}
```
üë§ **User**: *"I don't know"*  
ü§ñ **Bot Re-prompts with the same options**

---

## **üöÄ Summary of Fixes**
‚úî **Handles cases where user selects an option from `"did_you_mean"`**  
‚úî **Handles `"Yes"` confirmation when only one match exists**  
‚úî **Re-prompts if user input is unclear**  
‚úî **Ensures OpenSearch is used efficiently and correctly**  

üöÄ **Now the bot is more interactive and adapts intelligently to user input!** Let me know if you need further refinements! üéØ

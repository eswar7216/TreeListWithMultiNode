# Formulary Search AI - Updated to Query OpenSearch

# ========================
# Directory: src/main.py
# ========================

from fastapi import FastAPI, Request
from api.routes import router
import logging
import time

# Configure Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

app = FastAPI()
app.include_router(router)

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """ Middleware to log incoming requests and execution time. """
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    logger.info(f"{request.method} {request.url} - {response.status_code} - {process_time:.3f}s")
    return response

@app.get("/")
def read_root():
    logger.info("Root endpoint accessed.")
    return {"message": "Formulary Search AI is running!"}

# ========================
# Directory: src/api/routes.py
# ========================

from fastapi import APIRouter, HTTPException
from models.query_model import QueryRequest
from services.ai_gateway import process_query
from services.opensearch import query_opensearch
import os
import logging
import json
from collections import defaultdict

router = APIRouter()
logger = logging.getLogger(__name__)

# In-memory conversation history storage
conversation_history = defaultdict(list)

@router.post("/ask/{conversation_id}")
async def ask_bot(conversation_id: str, request: QueryRequest):
    user_query = request.query
    
    logger.info(f"Received query for conversation {conversation_id}: {user_query}")
    
    # Retrieve conversation history
    history = conversation_history[conversation_id]
    history.append({"role": "user", "content": user_query})
    
    ai_response = process_query(user_query, history)
    logger.info(f"AI Gateway processed response: {ai_response}")
    
    history.append({"role": "assistant", "content": ai_response})
    
    if isinstance(ai_response, dict) and "tool_calls" in ai_response:
        logger.info("AI returned tool_calls, executing queries.")
        return {"results": query_opensearch(ai_response["tool_calls"])}
    
    logger.info("AI returned direct response.")
    return {"response": ai_response}

# ========================
# Directory: src/services/opensearch.py
# ========================

import requests
import os
import logging

logger = logging.getLogger(__name__)

OPENSEARCH_URL = os.getenv("OPENSEARCH_URL", "http://localhost:9200/fps_um/_search")

def query_opensearch(tool_calls):
    results = []
    for tool_call in tool_calls:
        params = tool_call["parameters"]
        formulary_name = params.get("formulary_name")
        year = params.get("year")
        attribute = params.get("attribute")
        
        query = {
            "query": {
                "bool": {
                    "must": [
                        {"match": {"_source.formulary_nme": formulary_name}},
                        {"match": {"_source.invoice_yr": str(year)}}
                    ]
                }
            }
        }
        
        logger.info(f"Querying OpenSearch: {query}")
        response = requests.post(OPENSEARCH_URL, json=query)
        
        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            if hits:
                result = hits[0]["_source"].get(attribute, "Attribute not found")
                results.append({attribute: result})
            else:
                results.append({"error": "No matching record found"})
        else:
            logger.error(f"Error querying OpenSearch: {response.text}")
            results.append({"error": "Failed to fetch data from OpenSearch"})
    
    return results

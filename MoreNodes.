To ensure the **LLM always returns `tool_calls` in the correct format**, we need to **strictly enforce JSON validation** in the prompt. Here‚Äôs how we fix it:

---

## **‚úÖ 1Ô∏è‚É£ Updated `prompts.yaml` (Strict JSON Enforcement for `tool_calls`)**
### **üîπ Fixes**
- Forces the LLM to **always return `tool_calls` in the same JSON format**.
- Ensures missing parameters are **explicitly listed**.
- Prevents random formatting errors.
- Clearly **defines the allowed `tool_calls`**.

```yaml
prompts:
  context_prompt: |
    You are an AI assistant that determines the intent of a user query and generates structured tool calls.

    **Your response must always be in strict JSON format with a "context" key.**

    - If the user is asking a general NLP question (e.g., "How does formulary placement work?"), respond:
      ```json
      {
        "context": "nlp",
        "message": "Formulary placement determines where a drug is listed in an insurance plan. Would you like to ask about a specific formulary?"
      }
      ```
    
    - If the user is searching for formulary details, respond with **valid `tool_calls` in a strict JSON format**:

      **‚úÖ Valid `tool_calls` Format:**
      ```json
      {
        "context": "formulary_search",
        "tool_calls": [
          {
            "tool": "<tool_name>",
            "parameters": {
              "formulary_name": "<formulary_name>",
              "year": "<year>",
              "brand_name": "<brand_name>",
              "attribute": "<attribute>"
            }
          }
        ],
        "missing_parameters": ["<parameter_name>"]
      }
      ```

      **üöÄ List of Supported `tool_calls`:**
      1. `"query_formulary"` ‚Üí Requires `formulary_name`, `year`, `attribute`
      2. `"query_drug_list"` ‚Üí Requires `formulary_name`, `year`
      3. `"query_fps_placement"` ‚Üí Requires `formulary_name`, `year`, `brand_name`
      4. `"query_um_rules"` ‚Üí Requires `formulary_name`, `year`, `brand_name`
      5. `"query_total_wac"` ‚Üí Requires `formulary_name`, `year`, `brand_name`
      
      **‚ö†Ô∏è If any required parameter is missing, always include `"missing_parameters"` to prompt the user.**

    - If OpenSearch finds **similar matches** and the user needs to confirm, respond:
      - If only **one option is available** and the user says `"Yes"` or `"Confirm"`:
        ```json
        {
          "context": "did_you_mean",
          "selected_value": "<option_provided>",
          "confirmed": true
        }
        ```
      - If there are **multiple options**, and the user selects one:
        ```json
        {
          "context": "did_you_mean",
          "selected_value": "<selected_option>",
          "confirmed": true
        }
        ```
      - If the user **provides an invalid response**:
        ```json
        {
          "context": "did_you_mean",
          "selected_value": null,
          "confirmed": false,
          "message": "I didn't understand your selection. Please choose a valid option."
        }
        ```

    - If the query is unclear or not related to formulary data, respond:
      ```json
      {
        "context": "unknown",
        "message": "I'm not sure I understood your request. Can you clarify?"
      }
      ```

    **‚ö†Ô∏è IMPORTANT RULES FOR YOU:**
    - **Never generate `tool_calls` with missing keys.**
    - **Ensure all JSON keys and values are wrapped in double quotes ("").**
    - **Always return JSON. Never return plain text.**
```

---

## **‚úÖ 2Ô∏è‚É£ Why This Fix Works**
### **üîπ What This Does**
‚úî **Forces strict JSON validation** (no formatting errors).  
‚úî **Ensures `"tool_calls"` is always an array (even if it's one tool call).**  
‚úî **Enforces `"missing_parameters"` to handle incomplete queries.**  
‚úî **Prevents missing or incorrectly formatted keys.**  

### **üîπ Expected LLM Output (Always Valid)**
‚úÖ **Example (User asks for WAC of Lipitor in Express Scripts, but forgets year):**
```json
{
  "context": "formulary_search",
  "tool_calls": [
    {
      "tool": "query_total_wac",
      "parameters": {
        "formulary_name": "Express Scripts",
        "brand_name": "Lipitor"
      }
    }
  ],
  "missing_parameters": ["year"]
}
```
üëÜ **Bot now knows to ask: "Which year do you need?"**

‚úÖ **Example (User asks for placement of a drug in 2023 under a formulary):**
```json
{
  "context": "formulary_search",
  "tool_calls": [
    {
      "tool": "query_fps_placement",
      "parameters": {
        "formulary_name": "Express Scripts",
        "year": "2023",
        "brand_name": "Lipitor"
      }
    }
  ]
}
```
üëÜ **Bot correctly processes OpenSearch query.**

---

## **‚úÖ 3Ô∏è‚É£ Updated `process_query()` (Strict JSON Validation)**
Now, **we validate `tool_calls` before executing**.

```python
async def process_query(user_query, history):
    """
    Determines the context of the query before executing OpenSearch queries
    or handling NLP-related questions.
    """
    
    # Step 1: Determine query intent
    context_result = await derive_context(user_query, history)
    context = context_result.get("context")

    # Validate `tool_calls` format
    tool_calls = context_result.get("tool_calls", [])
    if not isinstance(tool_calls, list):
        return {
            "response_type": "error",
            "message": "Invalid tool_calls format. Expected a list."
        }

    for tool_call in tool_calls:
        if "tool" not in tool_call or "parameters" not in tool_call:
            return {
                "response_type": "error",
                "message": "Invalid tool_calls structure. Each tool_call must have 'tool' and 'parameters'."
            }

    # Handle NLP Queries
    if context == "nlp":
        return {
            "response_type": "message",
            "message": {
                "text": context_result["message"],
                "context": "info"
            }
        }

    # Handle Missing Parameters
    missing_parameters = context_result.get("missing_parameters", [])
    if missing_parameters:
        return {
            "response_type": "follow_up",
            "follow_up": {
                "question": f"Could you provide {missing_parameters[0]}?",
                "options": await query_valid_options(missing_parameters[0])
            }
        }

    # Handle Formulary Search Queries
    if context == "formulary_search":
        results = []
        for tool_call in tool_calls:
            tool = tool_call["tool"]
            params = tool_call["parameters"]

            # Validate known tools
            if tool not in ["query_formulary", "query_drug_list", "query_fps_placement", "query_um_rules", "query_total_wac"]:
                return {
                    "response_type": "error",
                    "message": f"Unsupported tool: {tool}"
                }

            result = await query_opensearch(tool, params)
            results.append(result)

        return {
            "response_type": "opensearch_results",
            "results": results
        }

    return {
        "response_type": "message",
        "message": {
            "text": "I couldn't determine your request. Please clarify.",
            "context": "error"
        }
    }
```

---

## **üöÄ Final Summary**
‚úî **LLM is now forced to always return `tool_calls` in a strict JSON format.**  
‚úî **Strict JSON validation ensures no missing parameters or incorrect formats.**  
‚úî **"Missing Parameters" logic dynamically asks for missing values.**  
‚úî **Prevents execution of invalid or incorrectly formatted `tool_calls`.**  

üöÄ **Now your bot will always get `tool_calls` in the proper format!** üéØ Let me know if you need any refinements. üöÄ

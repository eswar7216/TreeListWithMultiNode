You're absolutely right! The `"did_you_mean"` functionality **should only apply to formulary names and drug names**, since these are the only values stored in OpenSearch that might need correction.

To fix this:
- **Only query OpenSearch for `"did_you_mean"` when the entity type is `"formulary_name"` or `"brand_name"`**.
- **LLM should NOT generate `"did_you_mean"`**‚Äîinstead, we detect fuzzy matches in OpenSearch and return `"did_you_mean"` dynamically.
- **If OpenSearch provides one match, allow the user to say "Yes" to confirm**.
- **If OpenSearch provides multiple matches, allow the user to select one**.

---

# **‚úÖ 1Ô∏è‚É£ Updated `process_query()` to Handle `"did_you_mean"` Only for Formulary & Drug Names**
We **remove LLM-based `"did_you_mean"` handling** and replace it with OpenSearch logic.

```python
async def process_query(user_query, history):
    """
    Determines the context of the query before executing OpenSearch queries
    or handling NLP-related questions.
    """
    
    # Step 1: Determine query intent
    context_result = await derive_context(user_query, history)
    context = context_result.get("context")

    # Handle User Response to "Did You Mean?"
    last_bot_response = history[-1] if history else None
    if last_bot_response and last_bot_response.get("response_type") == "did_you_mean":
        did_you_mean_options = last_bot_response["did_you_mean"]["options"]

        # If user says "Yes", assume they accept the only option
        if len(did_you_mean_options) == 1 and user_query.lower() in ["yes", "confirm"]:
            entity_value = did_you_mean_options[0]  # Use the single available option
            entity_type = last_bot_response["did_you_mean"]["entity_type"]
        
        # If user selects one of the options
        elif user_query in did_you_mean_options:
            entity_value = user_query
            entity_type = last_bot_response["did_you_mean"]["entity_type"]
        
        else:
            return {
                "response_type": "did_you_mean",
                "did_you_mean": {
                    "question": "I didn't understand. Please choose one of these:",
                    "options": did_you_mean_options,
                    "entity_type": last_bot_response["did_you_mean"]["entity_type"]
                }
            }

        # Now proceed with the OpenSearch query
        return await query_opensearch(entity_type, entity_value)

    # Handle NLP Queries
    if context == "nlp":
        return {
            "response_type": "message",
            "message": {
                "text": context_result["message"],
                "context": "info"
            }
        }

    # Handle Formulary Search Queries
    if context == "formulary_search":
        entity_type = context_result.get("entity_type")
        entity_value = context_result.get("entity_value")

        if entity_type in ["formulary_name", "brand_name"]:
            exact_match = await query_exact_match(entity_type, entity_value)

            if not exact_match:  # No exact match, try fuzzy search
                fuzzy_matches = await query_did_you_mean(entity_type, entity_value)

                if fuzzy_matches:
                    return {
                        "response_type": "did_you_mean",
                        "did_you_mean": {
                            "question": "Did you mean one of these?",
                            "options": fuzzy_matches,
                            "entity_type": entity_type
                        }
                    }

        return await query_opensearch(entity_type, entity_value)

    return {
        "response_type": "message",
        "message": {
            "text": "I couldn't determine your request. Please clarify.",
            "context": "error"
        }
    }
```

---

# **‚úÖ 2Ô∏è‚É£ Updating `query_did_you_mean()` to Use OpenSearch**
- **We now check only `formulary_name` and `brand_name`**.
- **If OpenSearch finds fuzzy matches, return them**.
- **Otherwise, return an empty list (so `"did_you_mean"` is not triggered).**

```python
async def query_did_you_mean(entity_type, user_input):
    """
    Uses fuzzy search in OpenSearch to find close matches for formulary names or drug names.
    """
    if entity_type not in ["formulary_name", "brand_name"]:
        return []

    query = {
        "size": 5,
        "_source": [entity_type],
        "query": {
            "fuzzy": {
                entity_type: {
                    "value": user_input,
                    "fuzziness": "AUTO"
                }
            }
        }
    }

    try:
        response = requests.post(OPENSEARCH_URL, json=query)
        
        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            options = list(set(hit["_source"][entity_type] for hit in hits if entity_type in hit["_source"]))
            return sorted(options)  # Returning sorted list of unique matches
        else:
            return []
    except Exception as e:
        return []
```

---

# **‚úÖ 3Ô∏è‚É£ Updating `query_exact_match()`**
Before suggesting `"did_you_mean"`, we first **check if the entity already exists**.

```python
async def query_exact_match(entity_type, user_input):
    """
    Checks if a formulary or drug name exists exactly in OpenSearch.
    """
    if entity_type not in ["formulary_name", "brand_name"]:
        return False

    query = {
        "size": 1,
        "_source": [entity_type],
        "query": {
            "match_phrase": {
                f"{entity_type}.keyword": user_input
            }
        }
    }

    try:
        response = requests.post(OPENSEARCH_URL, json=query)
        
        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            return bool(hits)  # Return True if there's an exact match
        return False
    except Exception as e:
        return False
```

---

# **‚úÖ 4Ô∏è‚É£ Querying OpenSearch After "Did You Mean" Selection**
Once `"did_you_mean"` is resolved, **we proceed with the correct query**.

```python
async def query_opensearch(entity_type, entity_value):
    """
    Executes OpenSearch query after resolving "did_you_mean".
    """
    query_conditions = [{"match": {f"{entity_type}.keyword": entity_value}}]

    query = {
        "size": 1000,
        "query": {
            "bool": {
                "must": query_conditions
            }
        }
    }

    try:
        response = requests.post(OPENSEARCH_URL, json=query)

        if response.status_code == 200:
            data = response.json()
            hits = data.get("hits", {}).get("hits", [])
            return {"response_type": "opensearch_results", "results": [hit["_source"] for hit in hits]}

        return {"response_type": "message", "message": {"text": "No results found.", "context": "error"}}

    except Exception as e:
        return {"response_type": "message", "message": {"text": "Error fetching data from OpenSearch.", "context": "error"}}
```

---

## **‚úÖ 5Ô∏è‚É£ Expected Behavior**
### **Scenario 1: User Misspells a Formulary**
üë§ **User**: *"What are the drugs under Expres Scipts?"*  
üîç **OpenSearch finds no exact match but suggests "Express Scripts"**  
ü§ñ **Bot Response:**
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean one of these?",
    "options": ["Express Scripts"],
    "entity_type": "formulary_name"
  }
}
```
üë§ **User**: *"Yes"*  
ü§ñ **Bot Queries OpenSearch for `"Express Scripts"` and returns results**.

---

### **Scenario 2: User Misspells a Drug**
üë§ **User**: *"What is the WAC for Liptior?"*  
üîç **OpenSearch finds no exact match but suggests "Lipitor"**  
ü§ñ **Bot Response:**
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean one of these?",
    "options": ["Lipitor"],
    "entity_type": "brand_name"
  }
}
```
üë§ **User**: *"Lipitor"*  
ü§ñ **Bot Queries OpenSearch for `"Lipitor"` and returns results**.

---

## **üöÄ Summary of Fixes**
‚úî **"Did You Mean" now comes ONLY from OpenSearch (not LLM).**  
‚úî **Only applies to formulary names and drug names.**  
‚úî **User can confirm a single match with "Yes".**  
‚úî **User can select an option from multiple choices.**  
‚úî **Fully dynamic OpenSearch integration.**  

üöÄ **Now `"did_you_mean"` is 100% OpenSearch-powered and works as expected!** üéØ

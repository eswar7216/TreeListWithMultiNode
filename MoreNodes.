### **üîπ Adding "Did You Mean?" Feature**
You want the bot to:
1. **Query OpenSearch when user input has no exact match**.
2. **Return "Did You Mean?" suggestions** with close matches.
3. **Let the user select a correct option instead of failing immediately**.

This is **similar to `"follow_up"`** but will be a **new response type** called `"did_you_mean"`.

---

## **‚úÖ Updated JSON Response Format**
Now the bot can return one of these **structured responses**:

1Ô∏è‚É£ **Follow-up (`follow_up`)** ‚Üí When **required parameters are missing**, e.g., missing year or formulary name.  
2Ô∏è‚É£ **Did You Mean? (`did_you_mean`)** ‚Üí When **user input is slightly wrong** and we can suggest corrections.  
3Ô∏è‚É£ **Message (`message`)** ‚Üí When **no OpenSearch query is needed** (e.g., general error).  
4Ô∏è‚É£ **Tool Calls (`tool_calls`)** ‚Üí When the bot **has all details to query OpenSearch**.

---

## **1Ô∏è‚É£ Updated `prompts.yaml`**
We **tell the LLM** how to return `"did_you_mean"` responses.

```yaml
prompts:
  initial_prompt: |
    You are an AI assistant that helps users retrieve formulary details, drug placements, UM rules, and WAC.

    **Your responses must always follow one of these JSON formats:**

    - If a user‚Äôs question lacks necessary details (e.g., formulary_name, year, brand_name), return:
      {
        "response_type": "follow_up",
        "follow_up": {
          "question": "Could you specify the formulary year?",
          "options": ["2022", "2023", "2024"]
        }
      }

    - If the user input is slightly incorrect and close matches exist in OpenSearch, return:
      {
        "response_type": "did_you_mean",
        "did_you_mean": {
          "question": "Did you mean one of these?",
          "options": ["Express Scripts", "BlueCross", "Aetna"]
        }
      }

    - If no OpenSearch query is needed (error, general message, etc.):
      {
        "response_type": "message",
        "message": {
          "text": "I couldn't find that formulary. Please check the name.",
          "context": "error"
        }
      }

    - If the response requires querying OpenSearch:
      {
        "response_type": "tool_calls",
        "tool_calls": [
          {
            "tool": "query_drug_list_for_formulary",
            "parameters": {
              "formulary_name": "Express Scripts",
              "year": 2023
            }
          }
        ]
      }

    **Strictly follow this JSON structure. Do NOT use single quotes. Do NOT return raw text outside JSON.**
```

---

## **2Ô∏è‚É£ Updated `ai_gateway.py`**
We modify the `process_query` function to handle **both** `"follow_up"` and `"did_you_mean"`.

```python
import os
import json
import logging
from openai import AsyncAzureOpenAI
from prompts import prompts
from services.opensearch import query_valid_options, query_did_you_mean

logger = logging.getLogger(__name__)

AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")

azure_openai = AsyncAzureOpenAI(
    api_key=AZURE_OPENAI_API_KEY,
    api_version="2023-05-15",
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)

async def process_query(user_query, history):
    """
    Calls Azure OpenAI to determine the next action:
    - If missing parameters, queries OpenSearch for valid options.
    - If input is slightly incorrect, queries OpenSearch for similar matches.
    - If an NLP response is needed, returns a structured message.
    - If ready for OpenSearch, returns tool_calls.
    """
    messages = [
        {"role": "system", "content": prompts["initial_prompt"]}
    ] + history + [{"role": "user", "content": user_query}]
    
    try:
        response = await azure_openai.chat.completions.create(
            model="ai-coe-gpt4-8k-analyze",
            messages=messages,
            temperature=0.7
        )
        
        ai_response = response.choices[0].message.content
        logger.info(f"Raw LLM response: {ai_response}")

        # Convert LLM response to Python dict
        parsed_response = json.loads(ai_response)

        # Validate response_type
        if "response_type" not in parsed_response:
            return {
                "response_type": "message",
                "message": {
                    "text": "Invalid AI response format.",
                    "context": "error"
                }
            }

        # Handle follow-up cases by fetching valid options from OpenSearch
        if parsed_response["response_type"] == "follow_up":
            follow_up_question = parsed_response["follow_up"]["question"]
            options = await query_valid_options(follow_up_question)
            return {
                "response_type": "follow_up",
                "follow_up": {
                    "question": follow_up_question,
                    "options": options
                }
            }

        # Handle "Did You Mean?" cases by fetching closest matches from OpenSearch
        if parsed_response["response_type"] == "did_you_mean":
            match_question = parsed_response["did_you_mean"]["question"]
            matches = await query_did_you_mean(user_query)
            return {
                "response_type": "did_you_mean",
                "did_you_mean": {
                    "question": match_question,
                    "options": matches
                }
            }

        return parsed_response

    except json.JSONDecodeError:
        logger.error("LLM response is not valid JSON.")
        return {
            "response_type": "message",
            "message": {
                "text": "The AI response could not be processed.",
                "context": "error"
            }
        }

    except Exception as e:
        logger.error(f"Error processing query: {str(e)}")
        return {
            "response_type": "message",
            "message": {
                "text": "AI processing failed.",
                "context": "error"
            }
        }
```

---

## **3Ô∏è‚É£ New `query_did_you_mean()` in `opensearch.py`**
This function **fetches closest matches from OpenSearch**.

```python
import os
import requests
import logging

logger = logging.getLogger(__name__)

OPENSEARCH_URL = os.getenv("OPENSEARCH_URL", "http://localhost:9200/fps_um/_search")

async def query_did_you_mean(user_input):
    """
    Searches OpenSearch for similar terms when user input does not match exactly.
    """
    query = {
        "size": 5,  # Limit results
        "_source": ["formulary_name"],
        "query": {
            "fuzzy": {  # Use fuzzy search to find close matches
                "formulary_name": {
                    "value": user_input,
                    "fuzziness": "AUTO"
                }
            }
        }
    }

    response = requests.post(OPENSEARCH_URL, json=query)
    
    if response.status_code == 200:
        data = response.json()
        hits = data.get("hits", {}).get("hits", [])
        options = list(set(hit["_source"]["formulary_name"] for hit in hits if "formulary_name" in hit["_source"]))
        return sorted(options)  # Returning sorted list of unique matches
    else:
        return []
```

---

## **4Ô∏è‚É£ Example Bot Behavior**

### **Case 1: Missing Year (Follow-Up with Valid Options)**
üë§ **User**: *"What are the drugs under Express Scripts?"*  
ü§ñ **Bot Response (JSON)** (Fetched available years from OpenSearch)
```json
{
  "response_type": "follow_up",
  "follow_up": {
    "question": "For which year do you need the drug list?",
    "options": ["2021", "2022", "2023"]
  }
}
```

---

### **Case 2: Did You Mean?**
üë§ **User**: *"What are the drugs under Expres Scipts?"*  
ü§ñ **Bot Response (JSON)** (Using fuzzy search in OpenSearch)
```json
{
  "response_type": "did_you_mean",
  "did_you_mean": {
    "question": "Did you mean one of these?",
    "options": ["Express Scripts", "BlueCross", "Aetna"]
  }
}
```

---

### **üöÄ Summary of Fixes**
‚úî **Adds `"did_you_mean"` for fuzzy matches in OpenSearch**  
‚úî **Prevents user errors by offering suggestions**  
‚úî **Ensures structured JSON output**  
‚úî **Makes the bot more user-friendly and interactive**  

üöÄ **Now your bot can handle typos and suggest corrections!** Let me know if you need more improvements! üéØ

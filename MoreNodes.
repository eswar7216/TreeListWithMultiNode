### **üîπ Ensuring the LLM Returns Supported `tool_calls` and Handling in OpenSearch**
To make sure the LLM **only generates tool_calls that our system supports**, we need to:
1. **Define a strict list of supported `tool_calls` and parameters.**
2. **Ensure LLM returns parameters in a structured and predictable format.**
3. **Dynamically process tool calls in OpenSearch based on parameter availability.**

---

## **‚úÖ 1Ô∏è‚É£ Defining Supported `tool_calls` in `prompts.yaml`**
We will modify the `context_prompt` to enforce **strictly defined tools** with valid parameters.

```yaml
prompts:
  context_prompt: |
    You are an AI assistant that determines the intent of a user query and generates structured tool calls.

    **Your response must always be in JSON format with a "context" key.**

    - If the user is asking a general NLP question (e.g., "How does formulary placement work?"), respond:
      {
        "context": "nlp",
        "message": "Formulary placement determines where a drug is listed in an insurance plan. Would you like to ask about a specific formulary?"
      }

    - If the user is searching for formulary details, respond with one of the predefined tool calls:

      **Supported `tool_calls`:**
      1. `"query_formulary"` ‚Üí Requires `formulary_name`, `year`, `attribute`
      2. `"query_drug_list"` ‚Üí Requires `formulary_name`, `year`
      3. `"query_fps_placement"` ‚Üí Requires `formulary_name`, `year`, `brand_name`
      4. `"query_um_rules"` ‚Üí Requires `formulary_name`, `year`, `brand_name`
      5. `"query_total_wac"` ‚Üí Requires `formulary_name`, `year`, `brand_name`
      
      **If any required parameter is missing, include it in `"missing_parameters"` for a follow-up prompt.**

      **Example Correct Response for "What is the WAC for Lipitor under Express Scripts in 2023?"**
      ```json
      {
        "context": "formulary_search",
        "tool_calls": [
          {
            "tool": "query_total_wac",
            "parameters": {
              "formulary_name": "Express Scripts",
              "year": 2023,
              "brand_name": "Lipitor"
            }
          }
        ]
      }
      ```

      **Example Response When a Parameter is Missing:**
      ```json
      {
        "context": "formulary_search",
        "tool_calls": [
          {
            "tool": "query_total_wac",
            "parameters": {
              "formulary_name": "Express Scripts",
              "brand_name": "Lipitor"
            }
          }
        ],
        "missing_parameters": ["year"]
      }
      ```

    - If the query is unclear or not related to formulary data, respond:
      {
        "context": "unknown",
        "message": "I'm not sure I understood your request. Can you clarify?"
      }

    **Always return JSON. Never return plain text.**
```

---

## **‚úÖ 2Ô∏è‚É£ Handling `tool_calls` in `ai_gateway.py`**
Now that the LLM is **forced** to return structured `tool_calls`, we dynamically execute the correct OpenSearch query.

```python
async def process_query(user_query, history):
    """
    Determines the context of the query before executing the right OpenSearch query
    or handling NLP-related questions.
    """
    
    # Step 1: Determine query intent
    context_result = await derive_context(user_query, history)
    context = context_result.get("context")

    # Handle NLP Queries
    if context == "nlp":
        return {
            "response_type": "message",
            "message": {
                "text": context_result["message"],
                "context": "info"
            }
        }

    # Handle Formulary Search Queries
    if context == "formulary_search":
        tool_calls = context_result.get("tool_calls", [])
        missing_parameters = context_result.get("missing_parameters", [])

        if missing_parameters:
            return {
                "response_type": "follow_up",
                "follow_up": {
                    "question": f"Could you provide {missing_parameters[0]}?",
                    "options": await query_valid_options(missing_parameters[0])
                }
            }

        if not tool_calls:
            return {
                "response_type": "message",
                "message": {
                    "text": "I couldn't determine the correct action for your request.",
                    "context": "error"
                }
            }

        # Execute each tool call dynamically
        results = []
        for tool_call in tool_calls:
            tool = tool_call["tool"]
            params = tool_call["parameters"]

            if tool == "query_formulary":
                result = await query_opensearch("formulary", params)
            elif tool == "query_drug_list":
                result = await query_opensearch("drug_list", params)
            elif tool == "query_fps_placement":
                result = await query_opensearch("fps_placement", params)
            elif tool == "query_um_rules":
                result = await query_opensearch("um_rules", params)
            elif tool == "query_total_wac":
                result = await query_opensearch("total_wac", params)
            else:
                result = {"error": f"Unsupported tool: {tool}"}

            results.append(result)

        return {
            "response_type": "opensearch_results",
            "results": results
        }

    return {
        "response_type": "message",
        "message": {
            "text": "I couldn't determine your request. Please clarify.",
            "context": "error"
        }
    }
```

---

## **‚úÖ 3Ô∏è‚É£ Implementing `query_opensearch()` in `opensearch.py`**
Since the `tool_calls` are **now standardized**, we can write **a single function** to handle all OpenSearch queries.

```python
async def query_opensearch(query_type, params):
    """
    Handles all OpenSearch queries dynamically based on the query type.
    """
    query_conditions = []

    if query_type == "formulary":
        query_conditions.append({"match": {"formulary_name.keyword": params["formulary_name"]}})
    
    elif query_type == "drug_list":
        query_conditions.append({"match": {"formulary_name.keyword": params["formulary_name"]}})
        query_conditions.append({"match": {"year": params["year"]}})
    
    elif query_type == "fps_placement":
        query_conditions.append({"match": {"formulary_name.keyword": params["formulary_name"]}})
        query_conditions.append({"match": {"year": params["year"]}})
        query_conditions.append({"match": {"brand_name.keyword": params["brand_name"]}})
    
    elif query_type == "um_rules":
        query_conditions.append({"match": {"formulary_name.keyword": params["formulary_name"]}})
        query_conditions.append({"match": {"year": params["year"]}})
        query_conditions.append({"match": {"brand_name.keyword": params["brand_name"]}})
    
    elif query_type == "total_wac":
        query_conditions.append({"match": {"formulary_name.keyword": params["formulary_name"]}})
        query_conditions.append({"match": {"year": params["year"]}})
        query_conditions.append({"match": {"brand_name.keyword": params["brand_name"]}})

    else:
        return {"error": f"Unsupported OpenSearch query type: {query_type}"}

    query = {
        "size": 1000,
        "query": {
            "bool": {
                "must": query_conditions
            }
        }
    }

    response = requests.post(OPENSEARCH_URL, json=query)

    if response.status_code == 200:
        data = response.json()
        hits = data.get("hits", {}).get("hits", [])
        return [hit["_source"] for hit in hits] if hits else {"error": "No results found."}
    
    return {"error": f"Failed to fetch data from OpenSearch. Status: {response.status_code}"}
```

---

## **üöÄ Summary of Fixes**
‚úî **LLM is now strictly forced to return only supported `tool_calls`.**  
‚úî **Each tool call dynamically runs the correct OpenSearch query.**  
‚úî **Bot now ensures all required parameters exist before querying OpenSearch.**  
‚úî **One function (`query_opensearch`) handles all OpenSearch queries in a structured way.**  

üöÄ **Now, the bot always generates valid tool calls and efficiently queries OpenSearch!** Let me know if you need refinements! üéØ

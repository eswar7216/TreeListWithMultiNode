# Formulary Search AI - Complete Code with `tool_calls`, Local Mode, and Logging

# ========================
# Directory: src/main.py
# ========================

from fastapi import FastAPI, Request
from api.routes import router
import logging
import time

# Configure Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

app = FastAPI()
app.include_router(router)

@app.middleware("http")
async def log_requests(request: Request, call_next):
    """ Middleware to log incoming requests and execution time. """
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    logger.info(f"{request.method} {request.url} - {response.status_code} - {process_time:.3f}s")
    return response

@app.get("/")
def read_root():
    logger.info("Root endpoint accessed.")
    return {"message": "Formulary Search AI is running!"}

# ========================
# Directory: src/api/routes.py
# ========================

from fastapi import APIRouter, HTTPException
from models.query_model import QueryRequest
from services.ai_gateway import process_query
from services.opensearch import query_opensearch
from services.local_data import query_local_json
import os
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

# Function to execute tool calls dynamically
def execute_tool_calls(tool_calls):
    results = []
    for tool_call in tool_calls:
        if tool_call["tool"] == "query_formulary":
            formulary_name = tool_call["parameters"]["formulary_name"]
            attribute = tool_call["parameters"]["attribute"]
            logger.info(f"Executing tool call: {tool_call}")
            if os.getenv("LOCAL_MODE", "False").lower() == "true":
                results.append(query_local_json(formulary_name, attribute))
            else:
                results.append(query_opensearch(formulary_name, attribute))
    return results

@router.post("/ask")
async def ask_bot(request: QueryRequest):
    """ Processes AI response and executes `tool_calls` dynamically. """
    logger.info(f"Received query: {request.query}")
    user_query = request.query
    ai_response = process_query(user_query)

    if isinstance(ai_response, dict) and "tool_calls" in ai_response:
        logger.info("AI returned tool_calls, executing OpenSearch queries.")
        return {"results": execute_tool_calls(ai_response["tool_calls"])}

    logger.info("AI returned direct response.")
    return {"response": ai_response}

# ========================
# Directory: src/services/local_data.py
# ========================

import json
import os
import logging

LOCAL_JSON_FILE = "configs/local_data.json"
logger = logging.getLogger(__name__)

def query_local_json(formulary_name, attribute):
    """ Reads from local JSON file instead of OpenSearch in LOCAL_MODE. """
    try:
        # Check if file exists before opening
        if not os.path.exists(LOCAL_JSON_FILE):
            logger.error(f"Local JSON file not found: {LOCAL_JSON_FILE}")
            return {"error": f"Local JSON file not found: {LOCAL_JSON_FILE}"}

        # Read and parse JSON file
        with open(LOCAL_JSON_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Ensure JSON contains the expected structure
        if not isinstance(data, list):
            logger.error(f"Invalid JSON structure: Expected a list of objects in {LOCAL_JSON_FILE}")
            return {"error": "Invalid JSON structure in local data file"}

        # Find the matching formulary entry
        for entry in data:
            if entry.get("formulary_nme") == formulary_name:
                logger.info(f"Local data found for {formulary_name}: {attribute}")
                return {attribute: entry.get(attribute, "Attribute not found")}

        logger.warning(f"No matching formulary found in local JSON for {formulary_name}")
        return {"error": "No matching formulary found"}

    except json.JSONDecodeError as e:
        logger.error(f"JSON parsing error: {str(e)} in file {LOCAL_JSON_FILE}")
        return {"error": "Failed to parse JSON file"}

    except Exception as e:
        logger.error(f"Unexpected error reading JSON file: {str(e)}")
        return {"error": f"Unexpected error reading JSON file: {str(e)}"}


# ========================
# Directory: requirements.txt
# ========================

fastapi==0.109.0
uvicorn==0.27.0
requests==2.31.0
langchain==0.1.15
langchain-community==0.0.27
opensearch-py==2.3.1
azure-ai-textanalytics==5.3.0
azure-openai==1.0.0
python-dotenv==1.0.1
redis==5.0.1
pytest==7.4.3
pyyaml==6.0.1
jsonschema==4.19.0
